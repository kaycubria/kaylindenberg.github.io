<!DOCTYPE html>
<head>
  <title>Kay's DevBootcamp Blog</title>
  <meta charset="UTF-8">
  <link rel="stylesheet" type="text/css" href="../styles/default.css">
</head>

<main>
  <h1>Arrays and Hashes in Ruby</h1>
  <h2>Storing and Retrieving Data in Code</h2>
  <h4>Friday, December 5, 2014</h4>

  <section>
    <p>
      Hashes and arrays provide tools to store and access large quantities of data. Both index the objects – stings, numbers, arrays, etc. - they contain to make them easily accessible. Since arrays can be thought of as special types of hashes, let’s start by exploring hashes. 
    </p>

    <p>
      Hashes map objects to keys. You retrieve the object in the hash by calling it using its unique key. We can build a hash that stores information about which film won the Academy Award for best picture in a given year. The best_picture hash below would allow us to unlock which movie won the best picture using the date as our key.
    </p>

    <p>
      best_picutre {
1928 => ‘Wings’,
1934 => ‘It Happened One Night’ 
1939 => ‘Gone with the Wind’ 
1943 => ‘Casablanca’
}
    </p>

    <p>
      A quick call to best_picture(1943) will let us know that Casablanca was the winning picture that year. It’s important to note that keys don’t have to be numbers, they can be strings too! You could, for example, map colors to planet names or husbands to wives, or basically any unique key value to anything else you can think of!
    </p>

    <p>
      What happens if we want to make a hash of finishers in a 5K race, where we have a winner, and then a first, second and third runners-up. We might have the following hash:
    </p>

    <p>
      finishers {
0 => Fred
1 => Joe
2 => Rebecca
3 => Sam
}
    </p>

    <p>
      Just query finishers(2) to find out that Rebecca is the second runner-up in the race. This is a rather useful format, as there are many instances of lists where it is convenient to be able to find an object by its place on the list…
    </p>

    <p>
      Which brings us to arrays! Arrays behave like hashes, but instead of explicitly assigned keys, in arrays, keys are implicitly determined by an objects place within the array, starting from 0 and counting up as you move to the right (or, if you can count down from the end of the array by starting with -1 for the last object in the array, -2 for the second to last object and so forth). The example below transforms our 5k finishers hash into an array:
    </p>

    <p>
finishers_arr = [‘Fred’, ‘Joe’, ‘Rebecca’, ‘Sam’]
    </p>

    <p>
      Like with our finishers hash, if we ask our array to tell us who the second runner-up was by querying finishers_arr(2) we get Rebecca!
    </p>

    <p>
      As with almost anything, arrays’ simplicity comes with trade-offs. While arrays are a little easier to set up, since your key assignments are made for you in an array, arrays provide less flexibility and customization than hashes.
    </p>
  </section>
</main>

